<!DOCTYPE html>
<html>
    <head>
        <title></title>
        <meta charset="utf-8">

        <script>
            function print(a){
                document.write(a+'<br>')
            }

            //JS에서의 객체 종류 
            //1. 내장 객체(이미 존재) : document, window(document의 상위객체), navigator ...etc / Date, String, Number, Array ... 
            
            
            //2. 사용자(프로그래머) 정의 객체
            //객체 생성의 3가지 방법
            // ● [ECMA ver.5~ class 키워드 등장]

            // ● 1. litertal class [객체를 생성하면서 설계]
            //객체 참조변수부터 만듬
            var person={
                //[ property ]: 속성(멤버변수) - var 키워드 없이, 변수명 + : + 초기값
                name:"sam",//"변수명" : "값" - 이처럼 써도 무방하나 연관배열과 혼동되기에 권장X                
                age:20,//[ , ]로 구분

                //[ method ] : (멤버함수) - 일반적 함수 선언문 사용불가
                //클래스 내부 기능 : 메소드 , 외부 기능 : 함수
                show:function(){//메소드명 : 익명함수
                    document.write('show----------┐<br>')
                    //document.write(person.name+","+person.age+"<br>")--ERROR-property 인식 X
                    //JS에서 멤버변수를 지정할때는 반드시 this키워드 필요
                    document.write(this.name+","+this.age+"<br>")
                }
            }

            //객체의 property(속성|멤버)출력
            document.write(person.name+",")
            document.write(person.age+"<br>")
            person.show()//객체의 메소드 호출
            document.write('<hr>')

            //같은 능력을 가진 객체를 또 하나 만들고 싶다면 
            //리터럴객체 생성방법 :  멤버를 정의하는 코드를 또 써야함
            var person2={
                name:'robin',age:25,
                show:function() {
                    document.write(this.name+","+this.age+"<br>")
                },
                add:function(a, b){
                    document.write('sum : '+(a+b)+'<br>')
                }
            }

            person2.show()
            person2.show(2,3)//파라미터가 없는 함수에 값 전달 -ERROR없이 무시됨
            person2.add(10,7)
            person2.add(5)
            //person2.zico()없는 멤버를 호출하면 ERROR
            //JS의 유연함 - 객체의 멤버도 나중에 추가 가능
            person2.tel='010-1234-5678'//새로운 property 추가
            document.write('name : '+person2.name+", tel : "+person2.tel+'<br>')
            person2.out=function(){//새로운 method추가
                document.write('out : '+this.name+this.age+this.tel+'<br>')
            }
            person2.out()
            //값을 대입하지 않은 property 출력
            document.write(person.address)
            document.write('<hr>')
            //리터럴 객체의 한계 - class와 다르게 객체마다 새로이 멤버를 만들어야해서 같은 속성과 기능의 객체를 정의할때 불편







            //● 2. 생성자 함수를 이용한 객체 생성 : [new 키워드로 객체생성] - (native언어와 비슷)
            //객체의 설계도 정의 (붕어빵틀)
            function Student(){
                //property = [this.키워드 사용]
                this.name='aaa'
                this.age=20
                this.major='android'
                var country='korea'//지역변수
                city='seoul'//전역변수
                this.show=function(){
                    document.write('Student : '+this.name+', &nbsp'+this.age+', '+this.major+'<br>')
                }

                // 멤버변수에 값 대입해주는 기능메소드
                this.setMemebers=function(name, age, major){
                    this.name=name
                    this.age=age
                    this.major=major
                }
            }
            var s=new Student()//객체 생성
            s.name='mark'
            s.show()

            var s2=new Student()
            s2.name='ㅠㅠㅠ'
            s2.age=12345678
            s2.major='web'            
            s2.show()
            //멤버값을 일일이 대입 -> 멤버값을 자동으로 대입하는 기능(메소드) 이용
            var s3=new Student()
            s3.setMemebers('hoshi',25,'singer')
            s3.show()

            document.write('지역변수 : '+s.country+'<br>') 
            document.write('전역변수 (멤버일까?): '+s.city+'<br>') 
            document.write('전역변수 : '+city+'<br>') 


            //언제나 객체 new한후에 set메소드를 호출하는 것도 짜증!
            //new하면서 멤버값을 초기화하는 값 전달 [ 생성자함수 ]
            function Stu(name, age, major){
                this.name=name
                this.age=age
                this.major=major
                this.show=function(){
                    document.write('Stu : '+this.name+', &nbsp'+this.age+', '+this.major+'<br>')
                }
            }

            var stu=new Stu('sam',20,'webapp')
            stu.show()






            //////////////////////////////etx/////////////////////////////////////////

            //[ in ] : keyword(연산자)
            document.write('name' in stu)//stu객체 안에 'name'이라는 속성이 있는가?
            document.write('city' in stu)

            document.write('<hr>')



            //객체안 멤버가 또 다른 객체 일때
            var flight={
                airline: 'Korean air', Number :77,
                arrival: {
                    nation : 'japan',city : 'tokyo'
                }
            }
            print(flight.airline)
            print(flight.arrival.nation)
            print('<br><br>')

            //리터럴 객테의 단점 보완
            //객체 clone가능
            var p1={
                name:'aaa',age:55,
                show:function(){
                    document.write(this.name+','+this.age+'<br>')
                }
            }
            p1.show()
            var p2=Object.create(p1) //p1객체의 clone 객체 생성
            p2.name='bbb'
            p2.show()
            
            
        </script>
    </head>
    <body>
    </body>
</html>